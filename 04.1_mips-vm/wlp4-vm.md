# CS241 Emulator Access Failure and MIPS Virtual Machine Workaround

## The Problem: Failed Access to CS241 Tools

### What I Needed
- CS241 MIPS emulator for testing WLP4 compiled code
- Linker files for proper assembly linking
- Runtime environment for executing MIPS assembly output
- Development toolchain for compiler testing

### Access Barriers Encountered

**Institutional Restrictions**
- CS241 emulator appears to be course-specific software
- Limited to University of Waterloo students enrolled in the course
- No public distribution or open-source availability
- Course materials behind authentication barriers

**Missing Critical Components**
- **Linker file**: Essential for linking compiled object files
- **Runtime libraries**: Standard library implementations (init, I/O functions)
- **System calls**: Implementation of println, getchar, putchar
- **Memory management**: Heap allocation and deallocation routines

**Technical Documentation Gaps**
- Incomplete public documentation of emulator specifications
- Missing ABI (Application Binary Interface) details
- Unknown memory layout requirements
- Unclear calling conventions beyond basic MIPS standards

## The Workaround: MIPS Virtual Machine

### Concept Overview
Rather than accessing proprietary course tools, develop a cross-platform MIPS virtual machine that can execute the assembly code generated by a WLP4 compiler.

### Architecture Design

**Core VM Components**
```
┌─────────────────────────────────────┐
│            Host Platform            │
├─────────────────────────────────────┤
│         MIPS Virtual Machine        │
│  ┌─────────────┬─────────────────┐  │
│  │   CPU Core  │   Memory Layout │  │
│  │             │                 │  │
│  │ • 32 Regs   │ • Stack Array   │  │
│  │ • PC/ALU    │ • Heap Array    │  │
│  │ • Decoder   │ • Text Segment  │  │
│  └─────────────┴─────────────────┘  │
│  ┌─────────────────────────────────┐ │
│  │        System Interface         │ │
│  │ • I/O Handlers                  │ │
│  │ • System Calls                  │ │
│  │ • Memory Management             │ │
│  └─────────────────────────────────┘ │
└─────────────────────────────────────┘
```

**Memory Organization**
```
┌──────────────────────────────────────┐
│              VM Memory               │
├──────────────────────────────────────┤
│  Text Segment    │ Program Code      │
│  (int[] array)   │ MIPS Instructions │
├──────────────────┼───────────────────┤
│  Stack Array     │ Function Calls    │
│  (int[] stack)   │ Local Variables   │
│                  │ Return Addresses  │
├──────────────────┼───────────────────┤
│  Heap Array      │ Dynamic Alloc     │
│  (int[] heap)    │ new/delete        │
│                  │ Runtime Objects   │
└──────────────────┴───────────────────┘
```

### Implementation Strategy

**Platform-Specific Implementations**
- **C Implementation**: High performance, direct memory access
- **C++ Implementation**: Object-oriented design, better abstraction
- **Python Implementation**: Rapid prototyping, easier debugging

**Common ISA Architecture**
```c
// Core VM structure (C implementation)
typedef struct {
    // CPU State
    int registers[32];        // $0 to $31 (with $0 hardwired to 0)
    int pc;                   // Program counter
    int hi, lo;               // Multiplication/division results
    
    // Memory Arrays - No Address Translation
    int *text_segment;        // Program instructions
    int *stack_memory;        // Stack array
    int *heap_memory;         // Heap array
    
    // Memory Bounds
    int text_size;
    int stack_size;
    int heap_size;
    
    // Stack/Heap Pointers
    int stack_ptr;            // Current stack position
    int frame_ptr;            // Frame pointer
    int heap_ptr;             // Next available heap slot
} mips_vm_t;

// Direct array access - no virtual memory
int vm_load_word(mips_vm_t *vm, int *memory, int index);
void vm_store_word(mips_vm_t *vm, int *memory, int index, int value);
```

**Cross-Platform ISA Specification**
```
Standard MIPS32 Instruction Set:
- Arithmetic: ADD, SUB, MULT, DIV, etc.
- Logic: AND, OR, XOR, NOR, SLL, SRL, SRA
- Memory: LW, SW, LB, SB, LH, SH
- Branch: BEQ, BNE, BLT, etc.
- Jump: J, JAL, JR, JALR
- Immediate: ADDI, ANDI, ORI, LUI, LIS
- System: SYSCALL for I/O operations

WLP4 Runtime Functions:
- init: Initialize heap allocator
- println: Print integer + newline
- putchar: Output single character
- getchar: Read single character
- new/delete: Dynamic memory management
```

**Runtime System**
- Implementation of WLP4 runtime functions:
  - `init`: Memory initialization
  - `println(int)`: Integer output with newline
  - `putchar(int)`: Character output
  - `getchar()`: Character input
- Dynamic memory allocation (`new`/`delete`)
- Proper calling convention handling

**Assembly Loading**
- Parse MIPS assembly text files
- Symbol resolution and address calculation
- Binary image generation in memory
- Entry point detection and initialization

### Platform Independence Benefits

**Cross-Platform Execution**
```
WLP4 Source → Compiler → MIPS Assembly → VM → Any Platform
```

**Advantages Over Native Emulator**
- Runs on Windows, macOS, Linux without modification
- No institutional access requirements
- Complete control over runtime environment
- Debugger integration possibilities
- Custom extensions and optimizations

**Educational Value**
- Deeper understanding of computer architecture
- Virtual machine implementation experience
- System-level programming knowledge
- Debugging and profiling capabilities

### Development Roadmap

**Phase 1: Core VM**
1. Basic MIPS instruction interpreter
2. Register file and memory simulation
3. Simple assembly loader
4. Basic I/O system calls

**Phase 2: WLP4 Integration**
1. Runtime library implementation
2. Memory allocation system
3. Calling convention compliance
4. Error handling and debugging

**Phase 3: Platform Optimization**
1. Performance profiling
2. Platform-specific optimizations
3. Memory usage improvements
4. Cross-platform testing

### Development Roadmap

**Phase 1: Core VM**
1. Basic MIPS instruction interpreter
2. Register file and memory simulation
3. Simple assembly loader
4. Basic I/O system calls

**Phase 2: WLP4 Integration**
1. Runtime library implementation
2. Memory allocation system
3. Calling convention compliance
4. Error handling and debugging

**Phase 3: Optimization**
1. Performance profiling
2. Instruction caching
3. Memory optimization
4. User interface improvements

## Alternative Solutions Considered

### SPIM Emulator
- Existing MIPS simulator
- Different runtime environment
- Incompatible with CS241 expectations
- Would require significant adaptation

### QEMU User Mode
- Full system emulation overkill
- Complex setup requirements
- Not designed for educational use
- Difficult debugging integration

### Native Cross-Compilation
- Platform-specific toolchains
- Complex linking requirements
- Limited portability
- Debugging complications

## Conclusion

The failure to access CS241's proprietary emulator and linker tools necessitated developing a custom MIPS virtual machine. This workaround not only solves the immediate problem but provides additional benefits including platform independence, complete control over the runtime environment, and valuable learning opportunities in virtual machine implementation.

The VM approach transforms a limitation into an opportunity for deeper technical understanding while ensuring the WLP4 compiler can be tested and used across different platforms without institutional dependencies.